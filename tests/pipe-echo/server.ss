(import (chezscheme)
        (choice))

(define-record-type server
 (fields (mutable loop) 
         (mutable handle)
         (mutable cli)
         (mutable srv))
 (protocol (lambda (new) (lambda () (new #f #f #f #f)))))

(define (server-init srv)
 (let* ((loop (make-loop))
       (handle (make-pipe-handle loop #t)))
  (server-loop-set! srv loop)
  (server-handle-set! srv handle)))

(define (server-run srv path)
 (let ((handle (server-handle srv))
       (loop (server-loop srv)))
  (uv-pipe-bind handle path)
  (uv-listen handle 64 (handle-conn srv))
  (uv-run loop uv-run-default)))

(define (handle-conn srv)
 (lambda (server status)
  (let ((client (make-tcp-handle (server-loop srv)))
        (s (server-handle srv)))
   (uv-accept s client)
   (display "accept\n")
   (server-cli-set! srv client)
   (echo-start srv))))

(define (echo-start srv)
 (let ((client (server-cli srv)))
  (display "echo start\n")
  (uv-read-start client alloc-cb read-cb)))

(define (alloc-cb hanlde size buf)
 (display "alloc cb\n")
 (uv-buf-fill buf size))

(define (read-cb handle size buf)
 (display "read cb\n")
 (if (> size 0)
  (let ((cnt (uv-buf->string buf)))
   (display cnt)
   (display "\n")
   (uv-try-write handle buf 1))
  (begin
   (display "empty\n")
   (uv-close handle))))

(define (server-stop srv)
 (let ((loop (server-loop srv))
       (handle (server-handle srv)))
  (uv-close handle close-cb)
  (uv-loop-stop loop)))

(define (close-cb handle)
 (display "closed"))
